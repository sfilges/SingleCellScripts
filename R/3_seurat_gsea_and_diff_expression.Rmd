---
title: "(3) Differential Expression & Gene Set Enrichment"
author: "Stefan Filges"
date: '`r format(Sys.Date())`'
output: 
  html_document:
    theme: sandstone
    highlight: tango
    code_folding: show
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Finding marker genes between clusters

Seurat can help you find markers that define clusters via differential expression. 
By default, it identifes positive and negative markers of a single cluster 
(specified in ident.1), compared to all other cells. FindAllMarkers automates 
this process for all clusters, but you can also test groups of clusters vs. 
each other, or against all cells.

The min.pct argument requires a feature to be detected at a minimum percentage 
in either of the two groups of cells, and the thresh.test argument requires a 
feature to be differentially expressed (on average) by some amount between the 
two groups. You can set both of these to 0, but with a dramatic increase in time - 
since this will test a large number of features that are unlikely to be highly 
discriminatory. As another option to speed up these computations, max.cells.per.ident 
can be set. This will downsample each identity class to have no more cells than 
whatever this is set to. While there is generally going to be a loss in power, 
the speed increases can be significiant and the most highly differentially expressed 
features will likely still rise to the top.

```{r plots_all_markers, message=FALSE}
# Packages for main analysis, clustering, data structures etc.
suppressMessages(library(Seurat, quietly = TRUE))
suppressMessages(library(mclust, quietly = TRUE))
suppressMessages(library(biomaRt, quietly = TRUE))
suppressMessages(library(msigdbr, quietly = TRUE))
suppressMessages(library(clusterProfiler, quietly = TRUE))
suppressMessages(library(destiny, quietly = TRUE))
suppressMessages(library(SummarizedExperiment, quietly = TRUE))
suppressMessages(require(clusterExperiment, quietly = TRUE))
suppressMessages(library(MAST, quietly = TRUE))
suppressMessages(library(DESeq2, quietly = TRUE))
suppressMessages(library(sctransform, quietly = TRUE))

# Packages for data handeling and plotting
suppressMessages(library(reshape, quietly = TRUE))
suppressMessages(library(cowplot, quietly = TRUE))
suppressMessages(library(tidyverse, quietly = TRUE))
suppressMessages(library(viridis, quietly = TRUE))
suppressMessages(library(RColorBrewer, quietly = TRUE))
suppressMessages(library(VennDiagram, quietly = TRUE))
suppressMessages(library(DT, quietly = TRUE))

filter_cell_cycle = FALSE

# define the working directory
working_directory <- "~/GitHub/SingleCellScripts/"

# set other directories based on working directory
figures_dir <- paste(working_directory,"figures/",sep="")
rdata_dir <- paste(working_directory,"data/Rdata/",sep="")

# load object
seurat_object <- paste(rdata_dir, "seurat_object_final.Rdata", sep = "")
load(seurat_object)

markers <- Seurat::FindAllMarkers(
  object = merged_data,
  min.pct = 0.1,
  logfc.threshold = 1
)
```

We will select the top 5 marker genes per cluster and visualise them using a 
heatmap.

```{r heatmap, fig.width=10, fig.height=8, message=FALSE}
top5 <- markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)

Seurat::DoHeatmap(
  object = merged_data,
  features = top5$gene
) + 
  Seurat::NoLegend() +
  viridis::scale_fill_viridis(
    option = 'plasma'
)

Seurat::DoHeatmap(
  object = merged_data,
  features = top5$gene, 
  group.by = "group"
) + 
  Seurat::NoLegend() +
  viridis::scale_fill_viridis(
    option = 'plasma'
)

```

## Genes upregulated in adipogenesis

The gene set for genes upregulated in adipogenesis was obtained from 
[Broad Insitute](http://software.broadinstitute.org/gsea/msigdb/cards/HALLMARK_ADIPOGENESIS.html).

The list contains 200 genes annotated as HALLMARK_ADIPOGENESIS. We visualise 
this gene set using a heatmap. Many genes were not expressed and therefore omitted
from the plot.

```{r heatmap_adipogenesis, fig.width=10, fig.height=8, message=FALSE}

database <- paste(working_directory, 'data/MSigDB/', sep = '')

adipo_markers <- read_delim(
  file = paste(database, "hallmark_genes_upregulated_during_adipogenesis.txt", sep = ''),
  delim = "\t",
  col_names = c("gene")
)

Seurat::DoHeatmap(
  object = merged_data,
  features = adipo_markers$gene,
  group.by = 'group'
) + 
  Seurat::NoLegend() +
  viridis::scale_fill_viridis(
    option = 'plasma'
)
```

## Marker genes by sample

To perform differential expression testing on a Seurat object we use the 
FindMarkers markers function and define the classes for which to perform the
comparison using:

- ident.1: Identity class to define markers for
- ident.2: A second identity class for comparison. If NULL (default) - use all other cells for comparison.

The function can use different methods to perform DE testing:

- Wilcoxon rank sum test (Seurat default)
- MAST (single-cell RNAseq specific test)
- DESeq2 with ZinB-wave weights (originally developed for bulk RNAseq data)
- Other tests such as Student's t-test, poisson and negative bionomial models

Luecken and Theis recommend to use MAST or limma for DE testing, even though
DEseq2 was also well performing for single cell data despite being orignally
developed for bulk RNAseq when using it with [ZINB-WaVE](https://www.nature.com/articles/s41467-017-02554-5) (zero inflated negative 
binomial) weights included in the model. MAST fits two-part, generalized linear models 
that are specially adapted for bimodal and/or zero-inflated single cell 
gene expression data. DE testing should be run on uncorrected data with
technical covariates included in the model.

p-value adjustment in FindMarkers is performed using bonferroni correction based on the total 
number of genes in the dataset. Other correction methods are not recommended, 
as Seurat pre-filters genes using the arguments above, reducing the number of 
tests performed. p-values should be interpreted cautiously, as the genes used for 
clustering are the same genes tested for differential expression.

When using MAST or possion/negative bionomial model it is possible to define
covariates using the latent.vars argument. We could use 'nFeature_RNA', 'nCount_RNA' 
and 'percent.mt' as latent variables and require that genes are expressed in at least
5\% of cells in at least one of the group compared.

### Genes differentially regulated between scf-WT and scf-FD
```{r scf-WT-vs-FD, fig.width=6, fig.height=4, message=FALSE, warning=FALSE}
if(filter_cell_cycle){
  markers.scfWT_vs_scfFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-WT', 
    ident.2 = 'scf-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA', 'S.Score', 'G2M.Score'),
    min.pct = 0.05,
    group.by = 'group'
  )
} else {
  markers.scfWT_vs_scfFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-WT', 
    ident.2 = 'scf-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA'),
    min.pct = 0.05,
    group.by = 'group'
  )
}

# Select and plot genes with log2-fold-change >= 1 and order genes by log2 fold change
# for plotting in the heatmap
marker_selection = markers.scfWT_vs_scfFD[abs(markers.scfWT_vs_scfFD$avg_logFC) >= 1, ]
marker_selection = marker_selection[order(marker_selection$avg_logFC),]

markers.scfWT_vs_scfFD <- as_tibble(
  x = markers.scfWT_vs_scfFD,
  rownames = 'genes'
)

# Output markers as interactive data table
DT::datatable(markers.scfWT_vs_scfFD, options = list(pageLength = 5))

# Plot most differentially expressed markers in heatmap
Seurat::DoHeatmap(
  object = merged_data,
  features = rownames(marker_selection),
  group.by = 'group'
  ) + 
  Seurat::NoLegend() + 
  viridis::scale_fill_viridis(
    option = 'plasma'
  )
```

### Genes differentially regulated between xen-WT and xen-FD
```{r xen-WT-vs-FD, fig.width=6, fig.height=4, message=FALSE, warning=FALSE}
if(filter_cell_cycle){
  markers.xenWT_vs_xenFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'xenograft-WT', 
    ident.2 = 'xenograft-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA', 'S.Score', 'G2M.Score'),
    min.pct = 0.05,
    group.by = 'group'
  )
} else {
  markers.xenWT_vs_xenFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'xenograft-WT', 
    ident.2 = 'xenograft-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA'),
    min.pct = 0.05,
    group.by = 'group'
  )
}

# Select and plot genes with log2-fold-change >= 1 and order genes by log2 fold change
# for plotting in the heatmap
marker_selection = markers.xenWT_vs_xenFD[abs(markers.xenWT_vs_xenFD$avg_logFC) >= 1, ]
marker_selection = marker_selection[order(marker_selection$avg_logFC),]

markers.xenWT_vs_xenFD <- as_tibble(
  x = markers.xenWT_vs_xenFD,
  rownames = 'genes'
)

# Output markers as interactive data table
DT::datatable(markers.xenWT_vs_xenFD, options = list(pageLength = 5))

# Plot most differentially expressed markers in heatmap
Seurat::DoHeatmap(
  object = merged_data,
  features = rownames(marker_selection),
  group.by = "group"
  ) + 
  Seurat::NoLegend() + 
  viridis::scale_fill_viridis(
    option = 'plasma'
  )
```

### Genes differentially regulated between scf-FD and xen-FD
```{r scf-FD-vs-xen-FD, fig.width=6, fig.height=4, message=FALSE, warning=FALSE}
if(filter_cell_cycle){
  markers.scfFD_vs_xenFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-FD', 
    ident.2 = 'xenograft-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA', 'S.Score', 'G2M.Score'),
    min.pct = 0.05,
    group.by = 'group'
  )
} else {
  markers.scfFD_vs_xenFD <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-FD', 
    ident.2 = 'xenograft-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA'),
    min.pct = 0.05,
    group.by = 'group'
  )
}

# Select and plot genes with log2-fold-change >= 1 and order genes by log2 fold change
# for plotting in the heatmap
marker_selection = markers.scfFD_vs_xenFD[abs(markers.scfFD_vs_xenFD$avg_logFC) >= 1, ]
marker_selection = marker_selection[order(marker_selection$avg_logFC),]

markers.scfFD_vs_xenFD <- as_tibble(
  x = markers.scfFD_vs_xenFD,
  rownames = 'genes'
)

# Output markers as interactive data table
DT::datatable(markers.scfFD_vs_xenFD, options = list(pageLength = 5))

# Plot most differentially expressed markers in heatmap
Seurat::DoHeatmap(
  object = merged_data,
  features = rownames(marker_selection),
  group.by = "group"
  ) + 
  Seurat::NoLegend() + 
  viridis::scale_fill_viridis(
    option = 'plasma'
  )
```

### Genes differentially regulated between scf-WT and xen-WT
```{r scf-WT-vs-xen-WT, fig.width=6, fig.height=4, message=FALSE, warning=FALSE}
if(filter_cell_cycle){
  markers.scfWT_vs_xenWT <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-WT', 
    ident.2 = 'xenograft-WT',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA', 'S.Score', 'G2M.Score'),
    min.pct = 0.05,
    group.by = 'group'
  )
} else {
  markers.scfWT_vs_xenWT <- Seurat::FindMarkers(
    merged_data, 
    ident.1 = 'scf-FD', 
    ident.2 = 'xenograft-FD',
    test.use = 'MAST',
    latent.var = c('nFeature_RNA'),
    min.pct = 0.05,
    group.by = 'group'
  )
}

# Select and plot genes with log2-fold-change >= 1 and order genes by log2 fold change
# for plotting in the heatmap
marker_selection = markers.scfWT_vs_xenWT[abs(markers.scfFD_vs_xenFD$avg_logFC) >= 1, ]
marker_selection = marker_selection[order(marker_selection$avg_logFC),]

markers.scfWT_vs_xenWT <- as_tibble(
  x = markers.scfWT_vs_xenWT,
  rownames = 'genes'
)

# Output markers as interactive data table
DT::datatable(markers.scfWT_vs_xenWT, options = list(pageLength = 5))

# Plot most differentially expressed markers in heatmap
Seurat::DoHeatmap(
  object = merged_data,
  features = rownames(marker_selection),
  group.by = "group"
  ) + 
  Seurat::NoLegend() + 
  viridis::scale_fill_viridis(
    option = 'plasma'
  )
```

## Gene list overlaps

```{r vennDiagrams, eval=FALSE}
library(VennDiagram)
library(RColorBrewer)

set1 <- markers.scfWT_vs_scfFD$genes
set2 <- markers.xenWT_vs_xenFD$genes
set3 <- markers.scfFD_vs_xenFD$genes

myCol <- brewer.pal(3, "Pastel2")

# Chart
venn.diagram(
        x = list(set1, set2, set3),
        category.names = c("scf.v.scf" , "xen.v.xen" , "scf.v.xen"),
        filename = 'figures/venn_diagramm.png',
        output=FALSE,
        
        # Output features
        imagetype="png" ,
        height = 480 , 
        width = 480 , 
        resolution = 300,
        compression = "lzw",
        
        # Circles
        lwd = 2,
        lty = 'blank',
        fill = myCol,
        
        # Numbers
        cex = .6,
        fontface = "bold",
        fontfamily = "sans",
        
        # Set names
        cat.cex = 0.6,
        cat.fontface = "bold",
        cat.default.pos = "outer",
        cat.pos = c(-27, 27, 135),
        cat.dist = c(0.055, 0.055, 0.085),
        cat.fontfamily = "sans",
        rotation = 1
)

set1 <- markers.scfWT_vs_scfFD$genes
set2 <- markers.xenWT_vs_xenFD$genes

common.markers <- dplyr::intersect(set1, set2)
```

# GSEA and GO term analysis

```{r, echo=FALSE}
##### Customize enricher function to match msigdbr results:

# We need to modifiy the enrichment analysis function to match more  closely the algorythm used in the msigdb website.
# The main difference is the definition of the universe (background), which in the GSEA web tool is defined as all the 
# genes in the NCBI database with a common gene name annotation, while in this package it is defined as all the genes that
# take part in any of the categories of the database analyzed.

enricher_custom <- function(
  gene,
  pvalueCutoff,
  pAdjustMethod = "BH",
  universe = NULL,
  minGSSize = 10,
  maxGSSize = 500,
  qvalueCutoff = 0.2,
  USER_DATA) {
  
    gene <- as.character(unique(gene))
    qExtID2TermID <- EXTID2TERMID(gene, USER_DATA)
    qTermID <- unlist(qExtID2TermID)
    
    if (is.null(qTermID)) {
      message("--> No gene can be mapped....")
      p2e <- get("PATHID2EXTID", envir = USER_DATA)
      sg <- unlist(p2e[1:10])
      sg <- sample(sg, min(length(sg), 6))
      message("--> Expected input gene ID: ", paste0(sg, collapse = ","))
      message("--> return NULL...")
      return(NULL)
    }
    qExtID2TermID.df <- data.frame(
      extID = rep(names(qExtID2TermID),
                  times = lapply(qExtID2TermID, length)),
      termID = qTermID
    )
    
    qExtID2TermID.df <- unique(qExtID2TermID.df)
    qTermID2ExtID <- with(
      qExtID2TermID.df, split(as.character(extID),as.character(termID))
    )
    
    extID <- ALLEXTID(USER_DATA)
    
    if (missing(universe)) 
      universe <- NULL
    if (!is.null(universe)) {
      extID <- as.character(universe)
    }
    
    qTermID2ExtID <- lapply(qTermID2ExtID, intersect, extID)
    qTermID <- unique(names(qTermID2ExtID))
    termID2ExtID <- TERMID2EXTID(qTermID, USER_DATA)
    termID2ExtID <- lapply(termID2ExtID, intersect, extID)
    geneSets <- termID2ExtID
    idx <- get_geneSet_index(termID2ExtID, minGSSize, maxGSSize)
    
    if (sum(idx) == 0) {
      msg <- paste("No gene set have size >", minGSSize, "...")
      message(msg)
      message("--> return NULL...")
      return(NULL)
    }
    
    termID2ExtID <- termID2ExtID[idx]
    qTermID2ExtID <- qTermID2ExtID[idx]
    qTermID <- unique(names(qTermID2ExtID))
    
    k <- sapply(qTermID2ExtID, length)
    k <- k[qTermID]
    M <- sapply(termID2ExtID, length)
    M <- M[qTermID]
    N <- rep(length(extID), length(M))
    n <- rep(length(qExtID2TermID), length(M))
    args.df <- data.frame(
      numWdrawn = k - 1, 
      numW = M, 
      numB = N - M, 
      numDrawn = n
    )
    
    pvalues <- apply(
      args.df, 1, function(n) phyper(n[1], n[2], n[3], n[4], lower.tail = FALSE)
    )
    
    GeneRatio <- apply(
      data.frame(a = k, b = n), 1, function(x) paste(x[1], "/", x[2], sep = "", collapse = "")
    )
    
    BgRatio <- apply(
      data.frame(a = M, b = N), 1, function(x) paste(x[1], "/", x[2], sep = "", collapse = "")
    )
    
    Over <- data.frame(
      ID = as.character(qTermID), 
      GeneRatio = GeneRatio, 
      BgRatio = BgRatio, 
      pvalue = pvalues,
      stringsAsFactors = FALSE
    )
    
    p.adj <- p.adjust(Over$pvalue, method = pAdjustMethod)
    
    qobj <- tryCatch(qvalue(p = Over$pvalue, 
                            lambda = 0.05,
                            pi0.method = "bootstrap"),
                     error = function(e) NULL)
    
    if (class(qobj) == "qvalue") {
      qvalues <- qobj$qvalues
    }
    else {
      qvalues <- NA
    }
    
    geneID <- sapply(qTermID2ExtID, function(i) paste(i, collapse = "/"))
    geneID <- geneID[qTermID]
    
    Over <- data.frame(
      Over,
      p.adjust = p.adj,
      qvalue = qvalues,
      geneID = geneID, 
      Count = k, 
      stringsAsFactors = FALSE
    )
    
    Description <- TERM2NAME(qTermID, USER_DATA)
    
    if (length(qTermID) != length(Description)) {
      idx <- qTermID %in% names(Description)
      Over <- Over[idx, ]
    }
    
    Over$Description <- Description
    nc <- ncol(Over)
    Over <- Over[, c(1, nc, 2:(nc - 1))]
    Over <- Over[order(pvalues), ]
    Over$ID <- as.character(Over$ID)
    Over$Description <- as.character(Over$Description)
    row.names(Over) <- as.character(Over$ID)
    
    x <- new("enrichResult", result = Over, pvalueCutoff = pvalueCutoff, 
             pAdjustMethod = pAdjustMethod, qvalueCutoff = qvalueCutoff, 
             gene = as.character(gene), universe = extID, geneSets = geneSets, 
             organism = "UNKNOWN", keytype = "UNKNOWN", ontology = "UNKNOWN", 
             readable = FALSE)
    
    return(x)
}

enricher_edit<-function(gene, pvalueCutoff = 0.05, pAdjustMethod = "BH", universe, 
                         minGSSize = 10, maxGSSize = 500, qvalueCutoff = 0.2, TERM2GENE, 
                         TERM2NAME = NA) 
{
  USER_DATA <- build_Anno(TERM2GENE, TERM2NAME)
  enricher_custom(gene = gene, pvalueCutoff = pvalueCutoff, 
                  pAdjustMethod = pAdjustMethod, universe = universe, minGSSize = minGSSize, 
                  maxGSSize = maxGSSize, qvalueCutoff = qvalueCutoff, USER_DATA = USER_DATA)
}

body(enricher)<-body(enricher_edit)

environment(enricher_custom)<-environment(clusterProfiler:::enricher_internal)
```

Next we perform gene set enrichment (GSEA) and gene ontology (GO) analysis. We
will look at four reference databases:

- Gene ontology, biological processes (GO_BP)
- Reactome pathways 
- Hallmarks gene sets represent specific well-defined biological states or processes and display coherent expression
- Transcription factor targets (TFT)

We will plot the top 30 enrichments for each of the four groups for each
comparison made above.

## Scaffold WT vs. scaffold FD {.tabset}

```{r load_GO_data, message=FALSE}
GO_BP <- read.gmt("MSigDB/c5.bp.v7.0.symbols.gmt")
Reactome <- read.gmt("MSigDB/c2.cp.reactome.v7.0.symbols.gmt")
Hallmarks <- read.gmt("MSigDB/h.all.v7.0.symbols.gmt")
TFT <- read.gmt("MSigDB/c3.tft.v7.0.symbols.gmt")

hgnc_symbols <- read.csv("MSigDB/hgnc.txt", sep = '\t', header=TRUE)
hgnc_symbols <- hgnc_symbols$Approved.symbol

gene = markers.scfWT_vs_scfFD %>% 
  dplyr::filter(p_val_adj < 0.01) 
gene <- gene$genes

egmt <- enricher(
  gene,
  TERM2GENE=GO_BP,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

go_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Hallmarks,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

hallmarks_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Reactome,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

reactome_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=TFT,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

tft_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)


custom_dotplot <- function(
  egmt,
  showCategory = 20,
  x.axis = 'GeneRatio',
  font.size = 7
  ){
  
  data <- egmt@result %>% 
    dplyr::arrange(qvalue) %>%
    dplyr::select(-geneID) %>%
    tidyr::separate(GeneRatio, c("top", "bottom"), sep = "/") %>%
    dplyr::mutate(GeneRatio = as.numeric(top)/as.numeric(bottom))
  
  data <- head(data, showCategory)
  
  data$category <- factor(data$ID, levels = rev(data$ID))
  
  if(x.axis == 'GeneRatio') {
    dp <- ggplot(
      data = data,
      mapping = aes(x = GeneRatio, y = category, color = -log10(qvalue))
    ) +
      geom_point(aes(size = Count)) + 
      scale_color_continuous(
        low="red", high="blue", 
        name = '-log10(qvalue)', 
        guide=guide_colorbar(reverse=FALSE)
        ) +
      theme_minimal() + 
      theme(
        axis.line = element_line(color="black", size = 0.2),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = font.size)
        ) + guides(size = guide_legend(reverse = TRUE))
  } else if (x.axis == 'qvalue'){
    dp <- ggplot(
      data = data,
      mapping = aes(x = -log10(qvalue), y = category, color = GeneRatio)
    ) +
      geom_point(aes(size = Count)) + 
      scale_color_continuous(
        low="red", high="blue", 
        name = 'GeneRatio', 
        guide=guide_colorbar(reverse=FALSE)
        ) +
      theme_minimal() + 
      theme(
        axis.line = element_line(color="black", size = 0.2),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = font.size)
        ) + guides(size = guide_legend(reverse = TRUE))
  }

  return(dp)
}



```

### Gene ontology
```{r, echo=FALSE}
go_plot
```

### Hallmarks
```{r, echo=FALSE}
hallmarks_plot
```

### Reactome
```{r, echo=FALSE}
reactome_plot
```

### TFT
```{r, echo=FALSE}
tft_plot
```

## Xenograft WT vs. xenograft FD {.tabset}

```{r GO2, message=FALSE}
gene = markers.xenWT_vs_xenFD %>% 
  dplyr::filter(p_val_adj < 0.01) 
gene <- gene$genes

egmt <- enricher(
  gene,
  TERM2GENE=GO_BP,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

go_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Hallmarks,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

hallmarks_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Reactome,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

reactome_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=TFT,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

tft_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)
```

### Gene ontology
```{r, echo=FALSE}
go_plot
```

### Hallmarks
```{r, echo=FALSE}
hallmarks_plot
```

### Reactome
```{r, echo=FALSE}
reactome_plot
```

### TFT
```{r, echo=FALSE}
tft_plot
```

## Scaffold WT vs. xenograft WT {.tabset}

```{r GO_WT_WT, message=FALSE}
gene = markers.scfWT_vs_xenWT %>% 
  dplyr::filter(p_val_adj < 0.01) 
gene <- gene$genes

egmt <- enricher(
  gene,
  TERM2GENE=GO_BP,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

go_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Hallmarks,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

hallmarks_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Reactome,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

reactome_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=TFT,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

tft_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)
```

### Gene ontology
```{r, echo=FALSE}
go_plot
```

### Hallmarks
```{r, echo=FALSE}
hallmarks_plot
```

### Reactome
```{r, echo=FALSE}
reactome_plot
```

### TFT
```{r, echo=FALSE}
tft_plot
```

Next, we look a common markers differentially both in scf-WT vs scf-FD and
xen-WT vs xen-FD.

## Commonly regulated genes {.tabset}

```{r go_common_markers, message=FALSE, eval=FALSE}
gene = common.markers

egmt <- enricher(
  gene,
  TERM2GENE=GO_BP,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

go_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Hallmarks,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

hallmarks_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Reactome,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

reactome_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=TFT,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

tft_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)
```

### Gene ontology
```{r, echo=FALSE}
go_plot
```

### Hallmarks
```{r, echo=FALSE}
hallmarks_plot
```

### Reactome
```{r, echo=FALSE}
reactome_plot
```

### TFT
```{r, echo=FALSE}
tft_plot
```

Finally, we look at highly variable genes that are enriched globally, 
across all samples.

## Markers for highly variable genes {.tabset}

```{r GO3, message=FALSE}
gene <- VariableFeatures(object = merged_data)

egmt <- enricher(
  gene,
  TERM2GENE=GO_BP,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

go_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Hallmarks,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

hallmarks_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=Reactome,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

reactome_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)

egmt <- enricher(
  gene,
  TERM2GENE=TFT,
  pvalueCutoff = 0.05,
  pAdjustMethod = 'fdr',
  minGSSize = NA,
  maxGSSize = NA,
  qvalueCutoff = 0.05,
  universe = hgnc_symbols
)

tft_plot <- dotplot(
  egmt,
  showCategory = 20,
  font.size = 7
)
```

### Gene ontology
```{r, echo=FALSE}
go_plot
```

### Hallmarks
```{r, echo=FALSE}
hallmarks_plot
```

### Reactome
```{r, echo=FALSE}
reactome_plot
```

### TFT
```{r, echo=FALSE}
tft_plot
```
